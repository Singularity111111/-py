import pandas as pd
import glob
import os
import numpy as np
from datetime import datetime, timedelta, date
import io
import warnings
# 引入 SettingWithCopyWarning, 解决 AttributeError
from pandas.errors import SettingWithCopyWarning
import xlsxwriter

# 忽略 Pandas 链式赋值的警告, 以保持代码简洁
warnings.filterwarnings("ignore", category=SettingWithCopyWarning)

# ==================== 终极配置区 ====================
EXCHANGE_RATE = 281  # 汇率配置
SEARCH_PATH = "."    # 搜索本地源文件的路径
OUTPUT_FILENAME = '最终生成三维度报表.xlsx'
# 定义尝试读取本地CSV文件的编码列表：增加更多可能性
CSV_ENCODINGS = ['utf-8', 'gbk', 'latin1', 'ISO-8859-1', 'cp1252']

# === Google Sheet 消耗数据链接 ===
SPEND_SHEET_URL = "https://docs.google.com/spreadsheets/d/1v_GQLJ28byHFUqfcvdo2OtAbLQaMOCBL9x7Q-MqkjmI/export?format=csv"

# ==================== 最终输出字段定义 ====================
# A. 产品总汇表字段 (包含 '产品' 维度)
PRODUCT_COLS = [
    '日期', '产品', '总消耗(U)', '注册成本', '首充成本', '新增用户数', '充值人数', '充值金额(U)', '提现金额(U)', 
    '充减提(U)', '盈余率(%)', '首存人数', '首存充值金额(U)', '首存付费率(%)', '首存盈余率(%)', 
    '首存ARPPU', '新增付费人数', '新增充值金额(U)', '新增付费率(%)', '老用户充值人数', 
    '老用户充值金额(U)', '老用户付费率(%)', '老用户ARPPU', '老用户盈余率(%)', 'ARPPU', 
    '次日复充率(%)', '3日复充率(%)', '7日复充率(%)', '15日复充率(%)', '30日复充率(%)', 
    'LTV-7天', 'LTV-15天', 'LTV-30天', '裂变率', '历史消耗(U)', '历史充提差(U)', '辅助列'
]

# B. 部门总汇表字段 (包含 '部门' 维度)
DEPT_COLS = [
    '日期', '部门', '总消耗(U)', '注册成本', '首充成本', '新增用户数', '充值人数', '充值金额(U)', '提现金额(U)', 
    '充减提(U)', '盈余率(%)', '首存人数', '首存充值金额(U)', '首存付费率(%)', '首存盈余率(%)', 
    '首存ARPPU', '新增付费人数', '新增充值金额(U)', '新增付费率(%)', '老用户充值人数', 
    '老用户充值金额(U)', '老用户付费率(%)', '老用户ARPPU', '老用户盈余率(%)', 'ARPPU', 
    '次日复充率(%)', '3日复充率(%)', '7日复充率(%)', '15日复充率(%)', '30日复充率(%)', 
    'LTV-7天', 'LTV-15天', 'LTV-30天', '老用户充减提(U)', '历史消耗(U)', '历史充提差(U)', '老玩家日活'
]

# C. 渠道总汇表字段 (包含 '渠道来源' 和 '部门' 维度)
CHANNEL_COLS = [
    '日期', '部门', '渠道来源', '总消耗(U)', '注册成本', '首充成本', '新增用户数', '充值人数', '充值金额(U)', 
    '提现金额(U)', '充减提(U)', '盈余率(%)', '首存人数', '首存充值金额(U)', '首存付费率(%)', 
    '首存盈余率(%)', '首存ARPPU', '新增付费人数', '新增充值金额(U)', '新增付费率(%)', '老用户充值人数', 
    '老用户充值金额(U)', '老用户付费率(%)', '老用户ARPPU', '老用户盈余率(%)', 'ARPPU', 
    '次日复充率(%)', '3日复充率(%)', '7日复充率(%)', '15日复充率(%)', '30日复充率(%)', 
    'LTV-7天', 'LTV-15天', 'LTV-30天', '老用户充减提(U)', '历史消耗(U)', '历史充提差(U)', '老玩家日活'
]

# ==================== 辅助函数 ====================

def write_sheet_with_metadata(df, sheet_name, writer, period_type, exchange_rate):
    """
    将 DataFrame 写入 Excel, 并在顶部插入自定义的 metadata 行。
    """
    # 假设产品名称和充提差信息是固定的
    product_name = 'aa-巴基斯坦（EpiWin）'
    charge_diff = '充提差<20%'
    
    # 获取 xlsxwriter 工作簿和工作表对象
    workbook = writer.book
    # 如果 sheet_name 已经存在, 则直接使用, 否则创建
    if sheet_name not in writer.sheets:
        worksheet = workbook.add_worksheet(sheet_name)
        writer.sheets[sheet_name] = worksheet
    else:
        worksheet = writer.sheets[sheet_name]

    # 1. 写入第一行：产品名称和日期
    # 使用 base_df 的最大日期作为日报日期, 以解决日期缺失问题
    
    # *** 修复 3: 使用实际数据中的最大日期作为报表日期 ***
    try:
        report_date = df['日期'].max().strftime('%Y-%m-%d')
    except (KeyError, AttributeError):
        # 如果 df 中没有 '日期' 列 (例如环比表), 使用今天的日期
        report_date = date.today().strftime('%Y-%m-%d')
    
    # 日报的起始行从 A1 开始, 对比表从 D1 开始
    start_col_idx = 0 
    if period_type in ['周报表', '月报表']:
        start_col_idx = 3 # 从 D1 开始

    # 写入产品/充提差信息
    # 日报从 B1 开始, 周/月报从 D1 开始
    product_info_col = chr(ord('B') + start_col_idx)
    worksheet.merge_range(f'{product_info_col}1:{chr(ord(product_info_col)+4)}1', 
                          f'产品：{product_name}    {charge_diff}', 
                          workbook.add_format({'align': 'left', 'valign': 'vcenter'}))
    
    # 日报写入日期和备注
    if period_type == '日报':
        worksheet.write('H1', report_date)
        worksheet.write('L1', '备注：暂无消耗更新')
        
    # 2. 写入第二行 (空行)
    # 写入空行, 确保数据从第 4 行开始
    
    # 3. 写入第三行：报表名称, 单位, 汇率 (数据从第 4 行开始)
    title_text = f'{sheet_name.split("-")[0]}总汇表'
    title_col = chr(ord('B') + start_col_idx)
    
    # 合并单元格 B3 到 G3 (日报) 或 D3 到 I3 (对比表)
    merge_range_end_col = chr(ord(title_col) + 5)
    worksheet.merge_range(f'{title_col}3:{merge_range_end_col}3', 
                          title_text, 
                          workbook.add_format({'align': 'left', 'valign': 'vcenter'}))
    
    # 写入单位和汇率
    # 假设 ARPPU 在倒数第 5 列左右
    try:
        unit_col_idx = df.columns.get_loc('ARPPU') + start_col_idx + 1
    except:
        # 环比表可能没有 ARPPU 列, 估算位置
        unit_col_idx = len(df.columns) - 4 + start_col_idx
        
    worksheet.write(2, unit_col_idx, '单位：U')
    worksheet.write(2, unit_col_idx + 1, f'汇率：{exchange_rate}')

    # 4. 写入数据
    # 从第 4 行开始写入数据 (startrow=3)
    df.to_excel(writer, sheet_name=sheet_name, index=False, header=True, startrow=3)

def read_source_file(file_pattern):
    """读取指定模式下的最新文件, 并处理 CSV 编码及 CSV/Excel 识别问题"""
    files = glob.glob(os.path.join(SEARCH_PATH, file_pattern))
    if not files: 
        print(f"  [警告] 未找到文件: {file_pattern}"); 
        return None
    latest_file = max(files, key=os.path.getctime)
    print(f"  正在读取: {os.path.basename(latest_file)}")
    
    # 优先尝试读取为 CSV (处理编码问题)
    if file_pattern.endswith('.csv'):
        df = None
        for encoding in CSV_ENCODINGS:
            try:
                # 尝试用当前编码读取
                df = pd.read_csv(latest_file, encoding=encoding)
                print(f"  [成功] 使用 '{encoding}' 编码读取 CSV 文件成功.")
                return df
            except Exception:
                continue
        
        # 如果所有 CSV 尝试都失败了, 可能是 Excel 文件被错误命名为 CSV
        try:
            df = pd.read_excel(latest_file)
            print("  [成功] CSV 编码失败, 但以 Excel 格式读取成功.")
            return df
        except Exception as e_excel:
            print(f"  [错误] 文件读取失败: 所有尝试的编码 ({', '.join(CSV_ENCODINGS)}) 都未能成功解析文件, 且无法作为 Excel 读取: {e_excel}")
            return None
    
    # 对于明确的 Excel 文件 (.xlsx, .xls)
    else:
        try:
            return pd.read_excel(latest_file)
        except Exception as e: 
            print(f"  [错误] 读取文件失败: {e}"); 
            return None

def get_spend_data_from_google_sheet(url):
    """从Google Sheet链接自动获取消耗数据, 并处理数值转换错误"""
    print("正在从Google Sheet链接自动读取'消耗'数据...")
    try:
        # Pandas可以直接从URL读取CSV数据
        df_spend_raw = pd.read_csv(url)
        print("  [成功] 已从链接获取数据。")
        
        # 数据处理
        # 统一日期格式为 datetime.date
        df_spend_raw['日期'] = pd.to_datetime(df_spend_raw['日期'], format='%Y%m%d').dt.date
        
        # 筛选出所有数值列用于求和 (排除'日期'和'和'这两列)
        spend_cols = [col for col in df_spend_raw.columns if col not in ['日期', '和', '备注']]
        
        # === 修复：强制转换数值类型, 解决 can only concatenate str 错误 ===
        # errors='coerce' 会将无法转换的值（例如表格中的空值、文本）设为 NaN
        for col in spend_cols:
            df_spend_raw[col] = pd.to_numeric(df_spend_raw[col], errors='coerce')
        
        # 计算总消耗 (NaN 会被自动忽略)
        df_spend_raw['总消耗(U)'] = df_spend_raw[spend_cols].sum(axis=1)
        
        # 历史累计数据：使用累加和计算历史消耗
        df_spend_raw['历史消耗(U)'] = df_spend_raw['总消耗(U)'].cumsum()
        
        # 返回核心消耗数据
        return df_spend_raw[['日期', '总消耗(U)', '历史消耗(U)']]
    except Exception as e:
        print(f"  [错误] 自动读取Google Sheet失败: {e}")
        print("  请检查链接是否有效, 或者网络连接是否正常。")
        return pd.DataFrame(columns=['日期', '总消耗(U)', '历史消耗(U)'])

def calculate_metrics(df):
    """计算所有衍生指标, 并进行币种转换"""
    df = df.copy()
    
    # 1. 货币单位转换 (PKR -> U)
    currency_cols_pkr = [
        '充值金额', '提现金额', '首存充值金额', '老用户充值金额', 
        '投注金额', '佣金', '老用户提现金额', '新增充值金额' 
    ]
    for col in currency_cols_pkr:
        if col in df.columns and f'{col}(U)' not in df.columns:
            df[f'{col}(U)'] = df[col].astype(float) / EXCHANGE_RATE
        elif col in df.columns and f'{col}(U)' in df.columns:
            df[f'{col}(U)'] = df[f'{col}(U)'].astype(float)
        
    # 重命名 LTV/复充率 相关的列, 以便后续选择
    df.rename(columns={
        '次日留存(%)': '次日复充率(%)', 
        '3日留存(%)': '3日复充率(%)', 
        '7日留存(%)': '7日复充率(%)',
        '15日留存(%)': '15日复充率(%)',
        '30日留存(%)': '30日复充率(%)'
    }, inplace=True)

    # 2. 核心计算 (避免除零/无限大错误)
    with np.errstate(divide='ignore', invalid='ignore'):
        
        # 充减提
        df['充减提(U)'] = df.get('充值金额(U)', 0) - df.get('提现金额(U)', 0)
        df['历史充提差(U)'] = df.get('历史充提差(U)', 0) 
        df['老用户充减提(U)'] = df.get('老用户充值金额(U)', 0) - df.get('老用户提现金额(U)', 0)
        
        # 成本 / 盈余率
        df['总消耗(U)'] = df.get('总消耗(U)', 0) 
        df['注册成本'] = np.divide(df['总消耗(U)'], df.get('新增用户数', 0))
        df['首充成本'] = np.divide(df['总消耗(U)'], df.get('首存人数', 0))
        df['盈余率(%)'] = np.divide(df['充减提(U)'], df.get('充值金额(U)', 0))
        
        # 付费率 / ARPPU / ARPU
        df['首存付费率(%)'] = df.get('首存付费率(%)', 0)
        df['新增付费率(%)'] = np.divide(df.get('新增付费人数', 0), df.get('新增用户数', 0))
        df['老用户付费率(%)'] = np.divide(df.get('老用户充值人数', 0), df.get('老玩家日活', 0))
        df['付费率(%)'] = np.divide(df.get('充值人数', 0), df.get('日活跃玩家数', 0))
        
        # ARPPU (Average Revenue Per Paying User)
        df['首存ARPPU'] = np.divide(df.get('首存充值金额(U)', 0), df.get('首存人数', 0))
        df['新增ARPPU'] = np.divide(df.get('新增充值金额(U)', 0), df.get('新增付费人数', 0))
        df['老用户ARPPU'] = np.divide(df.get('老用户充值金额(U)', 0), df.get('老用户充值人数', 0))
        df['ARPPU'] = np.divide(df.get('充值金额(U)', 0), df.get('充值人数', 0)) # Total ARPPU
        
    # 3. 最终清理
    df.replace([np.inf, -np.inf], 0, inplace=True); df.fillna(0, inplace=True)
    return df

def generate_summary_sheet(df_source, group_key, final_cols, time_period_str, sheet_name, writer):
    """生成每日、每周总汇或每月总汇的标准报表, 并使用自定义 metadata 写入"""
    
    df_report = df_source.copy()
    
    # *** 修复 2: 将 总消耗(U) 从总表中带入, 以便进行渠道分解 ***
    # 找到所有数值列, 排除 group_key, 日期, 和历史累计字段 (历史字段在 main 中处理)
    sum_cols = [col for col in df_report.columns if col not in group_key and col != '日期' and '历史' not in col and not df_report[col].dtype == object]
    
    # 1. 对分组和日期进行求和 
    if time_period_str == '日报':
        # 日报：只需要日期当天的数据
        
        # 如果 group_key 为空 (产品日报), 则直接对所有数据求和, 实现单行总计
        if not group_key:
            # 单行总计: 使用 sum() 
            df_report = df_report[sum_cols].sum().to_frame().T
            # *** 修复 1: 重新添加日期字段 ***
            df_report['日期'] = df_source['日期'].max() if not df_source.empty else None
            # 重新添加 '产品' 列, 因为它是最终报表需要的
            df_report['产品'] = df_source['产品'].iloc[0] if '产品' in df_source.columns and not df_source.empty else '总计'
        # 如果 group_key 非空 (部门/渠道日报), 则按部门/渠道分组求和
        else:
            df_report = df_report.groupby(group_key)[sum_cols].sum().reset_index()

    else:
        # 周报/月报总汇：必须按 group_key (产品/部门/渠道) 分组并求和
        df_report = df_report.groupby(group_key)[sum_cols].sum().reset_index()
    
    # 2. 重新计算衍生指标
    df_report = calculate_metrics(df_report)
    
    # 3. 确保最终字段都存在, 并选择字段
    for col in final_cols:
        if col not in df_report.columns:
            df_report[col] = 0

    # 4. 如果是周报或月报总汇, 添加总计行
    if time_period_str != '日报':
        df_report_temp = df_report[final_cols].copy() 
        total_row = df_report_temp.sum(numeric_only=True).to_frame().T
        total_row = total_row.reindex(columns=df_report_temp.columns, fill_value=0)
        
        if group_key and '日期' not in group_key: 
            total_row[group_key[0]] = '总计' 
        
        df_report = pd.concat([df_report_temp, total_row], ignore_index=True)
        
        # 重新计算总计行的百分比/成本指标
        total_idx = df_report[df_report[group_key[0]] == '总计'].index
        df_total_calc = df_report.loc[total_idx].copy()
        df_total_calc = calculate_metrics(df_total_calc)
        metrics_to_update = ['注册成本', '首充成本', '盈余率(%)', '新增付费率(%)', '老用户付费率(%)', '付费率(%)', '首存ARPPU', '新增ARPPU', '老用户ARPPU', 'ARPPU']
        df_report.loc[total_idx, metrics_to_update] = df_total_calc[metrics_to_update].values
    else:
        # 日报选择最终列
        df_report = df_report[final_cols].copy()
        
    # 5. 输出到 Excel (使用 metadata writer)
    write_sheet_with_metadata(df_report, sheet_name, writer, time_period_str, EXCHANGE_RATE)

def generate_comparison_sheets(df_source, group_key, final_cols, writer, period_type='周'):
    """生成产品维度特殊的 '总汇' 和 '环比' 对比表"""
    
    df_report = df_source.copy()
    sum_cols = [col for col in df_report.columns if col not in group_key and col != '日期' and '历史' not in col and not df_report[col].dtype == object]
    
    # *** 修复 3: 使用数据中的最大日期来定义本期/上期, 以避免日期为空 ***
    max_date = df_source['日期'].max()
    
    if period_type == '周':
        # 基于数据的最大日期, 计算它所属的周的结束日期
        # 如果 max_date 是周日 (weekday=6), end_of_current = max_date
        # 如果 max_date 是周一 (weekday=0), end_of_current = max_date - 1 (如果今天运行, max_date是昨天的)
        end_of_current = max_date - timedelta(days=max_date.weekday()) + timedelta(days=6)
        start_of_current = end_of_current - timedelta(days=6)
        end_of_last = start_of_current - timedelta(days=1)
        start_of_last = end_of_last - timedelta(days=6)
        
        period_col = '周期'
        period_name = '周'
        date_format = '%m/%d'
    else: # 月
        # 假设月报是最近 30 天 vs 再前 30 天
        end_of_current = max_date
        start_of_current = end_of_current - timedelta(days=29)
        end_of_last = start_of_current - timedelta(days=1)
        start_of_last = end_of_last - timedelta(days=29)
        
        period_col = '月份' 
        period_name = '月'
        date_format = '%m/%d'
        
    # --- 阶段一：生成 产品XX总汇表 (累积日期) ---
    sheet_total_name = f'产品{period_name}总汇'
    
    # 筛选本期和上期数据
    df_current_period = df_source[(df_source['日期'] >= start_of_current) & (df_source['日期'] <= end_of_current)].copy()
    df_last_period = df_source[(df_source['日期'] >= start_of_last) & (df_source['日期'] <= end_of_last)].copy()

    df_total = pd.concat([df_current_period, df_last_period])
    # 周/月总汇按日期和产品分组
    df_total_grouped = df_total.groupby(['日期', group_key])[sum_cols].sum().reset_index()
    df_total_grouped = calculate_metrics(df_total_grouped)
    for col in final_cols:
        if col not in df_total_grouped.columns:
            df_total_grouped[col] = 0
            
    # 输出总汇表 (使用 metadata writer)
    write_sheet_with_metadata(df_total_grouped[final_cols], sheet_total_name, writer, period_type, EXCHANGE_RATE)


    # --- 阶段二：生成 产品XX报表 (对比环比) ---
    sheet_comp_name = f'产品{period_name}报表'
    
    # 定义最终输出的列, 确保包含 '开始' 和 '结束'
    comp_cols_raw = ['开始', '结束', '周期', '始日-末期'] + [col for col in final_cols if col not in ['日期', group_key, '辅助列']]
    metrics_cols = [col for col in final_cols if col not in ['日期', group_key, '辅助列']] 
    
    # 1. 计算上期总计 (单行总计)
    df_last_sum = df_last_period[sum_cols].sum().to_frame().T
    df_last_sum = calculate_metrics(df_last_sum)
    df_last_sum = df_last_sum.reindex(columns=df_last_sum.columns.tolist() + [col for col in metrics_cols if col not in df_last_sum.columns], fill_value=0)
    
    # **准备对比表特定的列**
    df_last_sum['开始'] = start_of_last.strftime(date_format)
    df_last_sum['结束'] = end_of_last.strftime(date_format)
    df_last_sum['周期'] = '上' + period_name
    df_last_sum['始日-末期'] = f"{start_of_last.strftime(date_format)}-{end_of_last.strftime(date_format)}"
    
    # 2. 计算本期总计 (单行总计)
    df_current_sum = df_current_period[sum_cols].sum().to_frame().T
    df_current_sum = calculate_metrics(df_current_sum)
    df_current_sum = df_current_sum.reindex(columns=df_current_sum.columns.tolist() + [col for col in metrics_cols if col not in df_current_sum.columns], fill_value=0)
    
    # **准备对比表特定的列**
    df_current_sum['开始'] = start_of_current.strftime(date_format)
    df_current_sum['结束'] = end_of_current.strftime(date_format)
    df_current_sum['周期'] = '本' + period_name
    df_current_sum['始日-末期'] = f"{start_of_current.strftime(date_format)}-{end_of_current.strftime(date_format)}"
    
    # 3. 创建环比行
    df_combined = pd.merge(
        df_current_sum.drop(['开始', '结束', '周期', '始日-末期'], axis=1, errors='ignore'), 
        df_last_sum.drop(['开始', '结束', '周期', '始日-末期'], axis=1, errors='ignore'), 
        left_index=True, 
        right_index=True,
        suffixes=('_current', '_last')
    )
    
    df_comp = pd.DataFrame()
    for col in metrics_cols:
        col_current = f'{col}_current'
        col_last = f'{col}_last'
        
        if col_current not in df_combined.columns or col_last not in df_combined.columns:
            df_comp[col] = ''
            continue
            
        # 环比计算逻辑
        if col in ['总消耗(U)', '充值金额(U)', '提现金额(U)', '充减提(U)', '历史消耗(U)', '历史充提差(U)', '新增用户数', '充值人数', '首存人数']:
            df_comp[col] = np.divide(
                df_combined[col_current] - df_combined[col_last], 
                df_combined[col_last]
            ).replace([np.inf, -np.inf], 0).apply(lambda x: f'{x:.1%}')
        elif col in ['注册成本', '首充成本', '盈余率(%)', '首存付费率(%)', '首存盈余率(%)', '新增付费率(%)', '老用户付费率(%)', '老用户盈余率(%)', '付费率(%)', '次日复充率(%)', '3日复充率(%)', '7日复充率(%)', '15日复充率(%)', '30日复充率(%)', '裂变率']:
            df_comp[col] = (df_combined[col_current] - df_combined[col_last]).replace([np.inf, -np.inf], 0).round(2)
        elif col in ['首存ARPPU', '新增ARPPU', '老用户ARPPU', 'ARPPU', 'LTV-7天', 'LTV-15天', 'LTV-30天', '老用户充减提(U)']:
            df_comp[col] = (df_combined[col_current] - df_combined[col_last]).replace([np.inf, -np.inf], 0).round(2)
        else:
            df_comp[col] = ''
    
    # **准备环比表特定的列**
    df_comp['开始'] = f'本{period_name}'
    df_comp['结束'] = f'上{period_name}'
    df_comp['周期'] = '环比'
    df_comp['始日-末期'] = f'本{period_name}-上{period_name}'

    # 4. 合并最终对比报表 (上期、本期、环比)
    final_comp = pd.concat([
        df_last_sum[comp_cols_raw], 
        df_current_sum[comp_cols_raw], 
        df_comp[comp_cols_raw]
    ], ignore_index=True)
    
    # 输出到 Excel (使用 metadata writer)
    write_sheet_with_metadata(final_comp, sheet_comp_name, writer, period_type, EXCHANGE_RATE)

# ==================== 主函数 ====================

def main():
    print("--- 终极报表生成器 (全自动三维度版) 开始运行 ---")
    
    # --- 1. 自动读取所有在线和本地数据源 ---
    df_spend = get_spend_data_from_google_sheet(SPEND_SHEET_URL)
    df_channel = read_source_file('download_渠道报表_*.csv') 
    df_ops = read_source_file('download_运营报表_*.csv') 
    df_ltv = read_source_file('download_新增用户LTV_*.csv')
    df_retention = read_source_file('download_用户留存_*.csv')
    
    # --- 2. 数据预处理和合并 ---
    print("\n--- 开始数据预处理和合并 ---")
    if df_channel is None or df_channel.empty: 
        print("[致命错误] 渠道报表是基础数据源, 请确保文件存在且能被正确读取。"); return

    df_channel['日期'] = pd.to_datetime(df_channel['日期']).dt.date
    if '产品' not in df_channel.columns: df_channel['产品'] = '未分类产品'
    if '部门' not in df_channel.columns: df_channel['部门'] = '未分类部门'
    if '渠道来源' not in df_channel.columns: df_channel['渠道来源'] = '未分类渠道'
    
    base_df = df_channel.copy()
    
    dfs_to_merge = [
        (df_ops, '运营报表', ['日期']), 
        (df_ltv, 'LTV报表', ['日期']), 
        (df_retention, '留存报表', ['日期']), 
        (df_spend, '消耗报表', ['日期'])
    ]
    
    for df, name, on_cols in dfs_to_merge:
        if df is not None and not df.empty:
            if '时间' in df.columns and '日期' not in df.columns: df.rename(columns={'时间': '日期'}, inplace=True)
            if '日期' not in df.columns: continue
            df['日期'] = pd.to_datetime(df['日期']).dt.date
            
            # 使用 base_df 的所有列 + df 的新列进行合并
            cols_to_use = df.columns.difference(base_df.columns).tolist() + on_cols
            base_df = pd.merge(base_df, df[cols_to_use], on='日期', how='left', suffixes=(None, '_y'))
            base_df.drop([col for col in base_df.columns if '_y' in str(col)], axis=1, inplace=True)

    base_df.fillna(0, inplace=True)

    # --- 3. 生成最终Excel ---
    print("\n--- 开始生成三维度日报、周报、月报 ---")
    
    # *** 修复 3: 使用数据中的最大日期来定义日报日期 ***
    # 确保 max_date 存在, 否则默认为今天 - 1
    if not base_df.empty:
        max_date = base_df['日期'].max()
    else:
        max_date = date.today() - timedelta(days=1)
    
    yesterday = max_date # 使用数据的最大日期作为日报日期
    
    df_daily = base_df[base_df['日期'] == yesterday].copy()
    
    # 周报日期范围基于 max_date
    end_of_week = max_date - timedelta(days=max_date.weekday()) + timedelta(days=6)
    start_of_week = end_of_week - timedelta(days=6)
    df_weekly = base_df[(base_df['日期'] >= start_of_week) & (base_df['日期'] <= end_of_week)].copy()
    
    # 月报日期范围基于 max_date
    end_of_month = max_date
    start_of_month = end_of_month - timedelta(days=29)
    df_monthly = base_df[(base_df['日期'] >= start_of_month) & (base_df['日期'] <= end_of_month)].copy()
    
    REPORT_CONFIGS = [
        # 产品日报: 单行总计, group_key: []
        (df_daily, [], PRODUCT_COLS, '日报', '产品-日报'),
        (df_weekly, ['产品'], PRODUCT_COLS, '周报总汇', '产品-周报总汇'),
        (df_monthly, ['产品'], PRODUCT_COLS, '月报总汇', '产品-月报总汇'),
        # 部门/渠道日报/总汇: 正确分组
        (df_daily, ['部门'], DEPT_COLS, '日报', '部门-日报'),
        (df_weekly, ['部门'], DEPT_COLS, '周报总汇', '部门-周报总汇'),
        (df_monthly, ['部门'], DEPT_COLS, '月报总汇', '部门-月报总汇'),
        (df_daily, ['部门', '渠道来源'], CHANNEL_COLS, '日报', '渠道-日报'),
        (df_weekly, ['部门', '渠道来源'], CHANNEL_COLS, '周报总汇', '渠道-周报总汇'),
        (df_monthly, ['部门', '渠道来源'], CHANNEL_COLS, '月报总汇', '渠道-月报总汇'),
    ]

    with pd.ExcelWriter(OUTPUT_FILENAME, engine='xlsxwriter') as writer:
        
        for df, group_key, final_cols, time_period, sheet_name in REPORT_CONFIGS:
            if not df.empty:
                generate_summary_sheet(df, group_key, final_cols, time_period, sheet_name, writer)

        if not df_weekly.empty:
            generate_comparison_sheets(df_weekly, '产品', PRODUCT_COLS, writer, period_type='周')
        if not df_monthly.empty:
            generate_comparison_sheets(df_monthly, '产品', PRODUCT_COLS, writer, period_type='月')
            
    print("\n" + "="*50)
    print(f"🎉 终极三维度报表生成成功！请在当前文件夹查看文件: {OUTPUT_FILENAME}")
    print("="*50)

if __name__ == '__main__':
    main()

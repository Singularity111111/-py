import time
import os
import glob
from datetime import date
from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.chrome.options import Options

# ==================== 配置区 ====================
CHROMEDRIVER_PATH = r"C:\Users\User\Downloads\chromedriver-win64\chromedriver-win64\chromedriver.exe"
LOGIN_URL = "https://admindmgkgir666.epiwin24admgf4f73402ghudsd9k1vie9g82h9.com/#/login"
USERNAME = "Touhou002"
PASSWORD = "123456"
# ================================================

def find_and_rename_newest_file(download_path, report_name, existing_files):
    """查找最新下载的文件并根据报表名称重命名"""
    print(f"  等待 '{report_name}' 文件下载完成...")
    time.sleep(15)
    
    current_files = set(glob.glob(os.path.join(download_path, '*.xlsx')) + glob.glob(os.path.join(download_path, '*.csv')))
    new_files = current_files - existing_files
    
    if not new_files:
        print(f"  [警告] 未找到为 '{report_name}' 下载的新文件！")
        return
    
    newest_file = new_files.pop()
    today_str = date.today().strftime('%Y-%m-%d')
    new_filename = f"download_{report_name}_{today_str}.csv"
    new_filepath = os.path.join(download_path, new_filename)
    
    if os.path.exists(new_filepath): os.remove(new_filepath)
    os.rename(newest_file, new_filepath)
    print(f"  [成功] 文件已重命名为: {new_filename}")

# --- 主程序 ---
print("--- 全能数据下载器开始运行 ---")
s = Service(CHROMEDRIVER_PATH)
chrome_options = Options()
# (伪装选项)
chrome_options.add_experimental_option("excludeSwitches", ["enable-automation"])
chrome_options.add_experimental_option('useAutomationExtension', False)
chrome_options.add_argument('user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/125.0.0.0 Safari/537.36')
chrome_options.add_argument('--disable-blink-features=AutomationControlled')

try:
    driver = webdriver.Chrome(service=s, options=chrome_options)
    wait = WebDriverWait(driver, 20)
    driver.get(LOGIN_URL)
    
    # (登录)
    print("页面加载中，等待登录框...")
    wait.until(EC.presence_of_element_located((By.XPATH, "//input[@placeholder='账户']"))).send_keys(USERNAME)
    driver.find_element(By.XPATH, "//input[@placeholder='密码']").send_keys(PASSWORD)
    driver.find_element(By.XPATH, "//button[contains(., '登录')]").click()
    
    # (手动验证)
    print("\n" + "="*50 + "\n脚本已暂停！请手动输入谷歌验证码并完成登录。")
    input("登录成功后，请回到此窗口，按 Enter (回车) 键继续...")
    print("\n" + "="*50 + "\n脚本已恢复，开始批量下载所有数据源...")

    # 定义我们需要下载的所有报表
    reports_to_download = [
        {"name": "渠道报表", "url": "https://admindmgkgir666.epiwin24admgf4f73402ghudsd9k1vie9g82h9.com/#/stat/dailySummaryChannel"},
        {"name": "运营报表", "url": "https://admindmgkgir666.epiwin24admgf4f73402ghudsd9k1vie9g82h9.com/#/stat/operateDaily"}, # 假设这是日运营报表的URL
        {"name": "用户留存", "url": "https://admindmgkgir666.epiwin24admgf4f73402ghudsd9k1vie9g82h9.com/#/stat/userRetentionLog"}, # 假设这是用户留存的URL
        {"name": "新增用户LTV", "url": "https://admindmgkgir666.epiwin24admgf4f73402ghudsd9k1vie9g82h9.com/#/stat/userLtvLog"} # 假设这是LTV的URL
    ]
    
    downloads_path = os.path.join(os.path.expanduser('~'), 'Downloads')

    for report in reports_to_download:
        print(f"\n--- 正在处理: {report['name']} ---")
        
        # 1. 直接跳转到报表页面
        print(f"  直接跳转到页面...")
        driver.get(report['url'])
        
        # 2. 点击【近30天】按钮
        print("  点击【近30天】快捷按钮...")
        try:
            wait.until(EC.element_to_be_clickable((By.XPATH, "//span[text()='近30天']"))).click()
        except Exception:
            # 如果没有近30天按钮，就手动设置日期（作为备用方案）
            print("  未找到【近30天】按钮，尝试手动设置日期...")
            end_date = date.today() - timedelta(days=1)
            start_date = end_date - timedelta(days=29)
            start_date_str = start_date.strftime('%Y-%m-%d')
            end_date_str = end_date.strftime('%Y-%m-%d')
            start_date_input = wait.until(EC.presence_of_element_located((By.XPATH, "//input[@placeholder='开始日期']")))
            end_date_input = driver.find_element(By.XPATH, "//input[@placeholder='结束日期']")
            start_date_input.clear(); time.sleep(0.5); start_date_input.send_keys(start_date_str)
            end_date_input.clear(); time.sleep(0.5); end_date_input.send_keys(end_date_str)
            driver.find_element(By.XPATH, "//body").click()

        time.sleep(1)
        
        # 3. 点击“查询”并等待
        print("  正在点击'查询'按钮...")
        try:
            query_button = wait.until(EC.presence_of_element_located((By.XPATH, "//button[contains(., '查询')]")))
            driver.execute_script("arguments[0].click();", query_button)
            print("  等待新数据加载（10秒）...")
            time.sleep(10) 
        except Exception:
            print("  未找到'查询'按钮，直接继续...")
            time.sleep(5)
            
        # 4. 记录下载前的文件状态并导出
        existing_files = set(glob.glob(os.path.join(downloads_path, '*.xlsx')) + glob.glob(os.path.join(downloads_path, '*.csv')))
        
        print("  正在点击'导出'按钮...")
        export_button = wait.until(EC.presence_of_element_located((By.XPATH, "//button[contains(., '导出')]")))
        driver.execute_script("arguments[0].click();", export_button)
        
        # 5. 查找并重命名文件
        find_and_rename_newest_file(downloads_path, report['name'], existing_files)

    print("\n" + "="*50)
    print("🎉 全部数据源下载成功！")
    print("="*50)

except Exception as e:
    print(f"\n脚本运行中发生错误: {e}")

finally:
    if 'driver' in locals() and driver:
        driver.quit()
    print("--- 脚本运行结束 ---")
